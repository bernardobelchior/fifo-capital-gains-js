export interface Operation {
  /**
   * Symbol that identifies the underlying security. It is used only for differentation between
   * operations of different securities. Can be the stock ticker or any other identifier that
   * is different from other securities'.
   */
  symbol: string

  /**
   * Date when the operation took place
   */
  date: Date

  /**
   * Price of the security when the operation took place.
   * If it is a buy operation, this is the buying price; if a sell operation,
   * then this is the selling price.
   */
  price: number

  /**
   * Number of units transacted.
   */
  amount: number

  /**
   * Type of the operation
   */
  type: 'BUY' | 'SELL'
}

export interface CapitalGains {
  /**
   * Sale that triggered the capital gains
   */
  sale: Operation

  /**
   * Capital gains triggered from the sale
   */
  capitalGains: number
}

export type Year = number

/**
 * Aggregation of the capital gains by year.
 * Maps from year to the capital gains realized in that year.
 */
export type YearlyCapitalGains = Record<Year, number>

/**
 * Calculates the FIFO capital gains for the given operation history.
 * It separates capital gains of securities using the symbols given
 * in each operation.
 *
 * @param operationHistory History of operations (buy and sales) to
 * calculate the capital gains for.
 *
 * @throws If the amount of securities of all sell operations of a given symbol
 * exceeds the amount of securities of all buy operations for the same symbol.
 * This indicates that there is an error in the input, since it is not possible
 * to sell more securities than the ones bought.
 *
 * @returns The FIFO capital gains for each sell operation
 */
export function calculateFIFOCapitalGains(
  operationHistory: Operation[]
): CapitalGains[] {
  const history = operationHistory.map((obj) => ({ ...obj }))
  const sales = history.filter(({ type }) => type === 'SELL')

  return sales.reduce<CapitalGains[]>(
    (capitalGains, sale) => [
      ...capitalGains,
      calculateCapitalGainsForSale(history, sale),
    ],
    []
  )
}

/**
 * Aggregates the capital gains generated by a sequence of sales by year
 *
 * @param saleCapitalGains Array of capital gains generated by sell operations
 *
 * @returns A map of year to capital gains generated in the given year
 */
export function aggregateByYear(
  saleCapitalGains: CapitalGains[]
): YearlyCapitalGains {
  return saleCapitalGains.reduce<YearlyCapitalGains>(
    (capitalGainsPerYear, { capitalGains, sale: { date } }) => ({
      ...capitalGainsPerYear,
      [date.getFullYear()]:
        (capitalGainsPerYear[date.getFullYear()] || 0) + capitalGains,
    }),
    {}
  )
}

function calculateCapitalGainsForSale(
  operationHistory: Operation[],
  sale: Operation
): CapitalGains {
  let capitalGains = 0
  const saleCopy = { ...sale }

  operationHistory
    .filter(
      ({ type, symbol, date }) =>
        type === 'BUY' && symbol === sale.symbol && date < sale.date
    )
    .forEach((buy) => {
      const amountSold = Math.min(sale.amount, buy.amount)

      buy.amount -= amountSold
      sale.amount -= amountSold
      capitalGains += amountSold * (sale.price - buy.price)
    })

  if (sale.amount > 0) {
    throw Error(
      `Amount of sales for symbol ${sale.symbol} exceeds the amount of buys.`
    )
  }

  return {
    capitalGains,
    sale: saleCopy,
  }
}
